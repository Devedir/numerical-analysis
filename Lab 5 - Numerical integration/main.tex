\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx} % Required for inserting images
\usepackage{amsmath}
\usepackage{listings} % code highlighting
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{setspace}
\usepackage{wrapfig}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false, 
    tabsize=2
}

\lstset{style=mystyle}
\lstset{ % polish letters in code blocks
  literate={ą}{{\k a}}1
  		     {Ą}{{\k A}}1
           {ż}{{\. z}}1
           {Ż}{{\. Z}}1
           {ź}{{\' z}}1
           {Ź}{{\' Z}}1
           {ć}{{\' c}}1
           {Ć}{{\' C}}1
           {ę}{{\k e}}1
           {Ę}{{\k E}}1
           {ó}{{\' o}}1
           {Ó}{{\' O}}1
           {ń}{{\' n}}1
           {Ń}{{\' N}}1
           {ś}{{\' s}}1
           {Ś}{{\' S}}1
           {ł}{{\l}}1
           {Ł}{{\L}}1
}

\title{MOwNiT - Laboratorium 5:\\
Całkowanie numeryczne}
\author{Wojciech Dąbek}
\date{9 kwietnia 2024}

\begin{document}

\maketitle

\section{Treści zadań laboratoryjnych}

\begin{enumerate}
    \item Obliczyć \(I = \int_0^1 \frac{1}{1+x}dx\) wg wzoru prostokątów, trapezów i wzoru Simpsona (zwykłego i złożonego \(n = 3,\ 5\)). Porównać wyniki i błędy.
    \item Obliczyć całkę \(I = \int_{-1}^1 \frac{1}{1 + x^2}dx\) korzystając z wielomianów ortogonalnych (np. Czebyszewa) dla \(n = 8\).
\end{enumerate}

\section{Treści zadań domowych}

\begin{enumerate}
    \item Obliczyć całkę \(I = \int_0^1 \frac{1}{1 + x^2}dx\) korzystając ze wzoru prostokątów dla\\
    \(h = 0.1\) oraz metody całkowania adaptacyjnego.
    \item Metodą Gaussa obliczyć następującą całkę \(\int_0^1 \frac{1}{x+3}dx\) dla \(n = 4\). Oszacować resztę kwadratury.
\end{enumerate}

\section{Rozwiązania zadań laboratoryjnych}

\subsection{}
Rozważana całka jest równa
\[I = \int_0^1 \frac{1}{1+x}dx = \log 2 \approx 0.69314718\]
Dla uproszczenia zapisu przyjmuję \(h = \frac{b - a}{n} = \frac{1}{n},\ x_i\) - granice przedziałów (np. \(0, \frac{1}{3}, \frac{2}{3}, 1\) dla \(n = 3\)).
Następujące wyniki i błędy otrzymujemy całkując dla \(N = 1,\ 3,\ 5\) metodą
\begin{itemize}
    \item prostokątów:
    \[S(f) = h \sum_{i=1}^{n-1} f(x_i + \frac{h}{2})\]
    \item trapezów:
    \[S(f) = \frac{h}{2} \sum_{i=0}^{n-1} [f(x_i) + f(x_{i+1})]\]
    \item wzoru Simpsona:
    \[S(f) = \frac{h}{3} \sum_{i=1}^{n/2} [f(x_{2i-2}) + f(x_{2i-1}) + f(x_{2i})]\]
\end{itemize}

\noindent
Co zrealizowałem przez poniższy program w języku C:

\begin{lstlisting}[language=C]
#include <stdio.h>
#include <math.h>

// pointer to function of one variable
typedef double (* FuncFp)(double);

double fun(double x) {
    return 1. / (x + 1.);
}

// pointer to quadrature function
typedef double (* QuadratureFp)(FuncFp, double, double, int);

// rectangle rule, midpoint
double quad_rect_mid(FuncFp f, double a, double b, int n) {
    double h = (b - a) / n;
    double sum = 0;
    for (double x = a + (h / 2); x < b; x += h)
        sum += f(x);
    return h * sum;
}

// trapezoidal rule
double quad_trap(FuncFp f, double a, double b, int n) {
    double h = (b - a) / n;
    double sum = 0;
    double prev = f(a);
    for (double x = a + h; x < b + h; x += h) {
        double new = f(x);
        sum += prev + new;
        prev = new;
    }
    return sum * h / 2;
}

// Simpson's rule
double quad_simpson(FuncFp f, double a, double b, int n) {
    double h = (b - a) / n;
    double sum = f(a) + 4 * f((a + a + h) / 2);
    for (double x = a + h; x < b; x += h)
        sum += 2 * f(x) + 4 * f((x + x + h) / 2);
    sum += f(b);
    return sum * h / 6;
}

int main() {
    const int N_array[] = {1, 3, 5};
    const QuadratureFp quad_array[] =
        {quad_rect_mid, quad_trap, quad_simpson};
    const char* names[] =
        {"Rectangle", "Trapezoidal", "Simpson's"};

    const double correct = log(2);

    for (int i = 0; i < 3; i++) {
        printf("%s rule:\n", names[i]);
        for (int n = 0; n < 3; n++) {
            double S = quad_array[i](fun, 0, 1, N_array[n]);
            printf("n = %d: S = %.10f, Error = %.10f\n",
                    N_array[n], S, fabs(correct - S));
        }
        printf("\n");
    }

    return 0;
}
\end{lstlisting}

\noindent
Wypisuje on następujące rezultaty:

\begin{verbatim}
Rectangle rule:
n = 1: S = 0.6666666667, Error = 0.0264805139
n = 3: S = 0.6897546898, Error = 0.0033924908
n = 5: S = 0.6919078857, Error = 0.0012392948

Trapezoidal rule:
n = 1: S = 0.7500000000, Error = 0.0568528194
n = 3: S = 0.7000000000, Error = 0.0068528194
n = 5: S = 0.6956349206, Error = 0.0024877401

Simpson's rule:
n = 1: S = 0.6944444444, Error = 0.0012972639
n = 3: S = 0.6931697932, Error = 0.0000226126
n = 5: S = 0.6931502307, Error = 0.0000030501
\end{verbatim}

\noindent
\textbf{Wnioski:} W każdym przypadku zwiększenie liczby podprzedziałów daje wyraźnie dokładniejsze wyniki. Metody prostokątów i trapezów skutkują podobną dokładnością. Niezwykle pozytywnie wyróżnia się tu wzór Simpsona.

\subsection{}
Dla porównania policzę najpierw dokładną wartość całki:
\[\int_{-1}^1 \frac{1}{1 + x^2}dx = \frac{\pi}{2} \approx 1.5707963\]

\noindent
Mam do czynienia z przedziałem skończonym \([-1, 1]\), więc posłużę się następującym ciągiem ortogonalnych wielomianów Legendre'a:
\[P_n(x) = \frac{1}{2^n \cdot n!} \frac{d^n}{dx^n}(x^2 - 1)^n\]
Do zastosowania tego typu kwadratury Gaussa-Legendre'a przyjmuję \(p(x) = 1\).\\
Kwadratur wysokiego rzędu używa się rzadko, więc stablicowane są tylko wartości węzłów i wag dla niskich rzędów. Do uzyskania takiej tablicy wartości dla \(n=8\) posłużyłem się \href{https://www.efunda.com/math/num_integration/findgausslegendre.cfm}{kalkulatorem portalu \textit{efunda}} otrzymując:

\begin{table}[h]
    \centering
    \begin{tabular}{c|c|c}
        \textit{k} & węzły \(x_k\) & wagi \(w_k\)\\
        \hline
        1 & -0.96029 & 0.101229\\
        2 & -0.796667 & 0.222381\\
        3 & -0.525532 & 0.313707\\
        4 & -0.183435 & 0.362684\\
        5 & 0.183435 & 0.362684\\
        6 & 0.525532 & 0.313707\\
        7 & 0.796667 & 0.222381\\
        8 & 0.96029 & 0.101229
    \end{tabular}
    \label{tab:table1}
\end{table}

\noindent
Pozostaje wstawić te wartości do wzoru:
\begin{align*}
    \int_{-1}^1 \frac{1}{1 + x^2}dx \approx\ S = \sum_{k=1}^8 w_k \frac{1}{1 + x_k^2} &= 1.5707957502350354\\
    \Delta S = \left|\frac{\pi}{2} - S\right| &\approx 5.765598611873202 \cdot 10^{-7}
\end{align*}
Co obliczyłem poniższym programem napisanym w języku Python.

\begin{lstlisting}[language=Python]
from math import pi

def f(x: float) -> float:
    return 1 / (1 + x*x)

weights = [
    (-0.96029, 0.101229), (-0.796667, 0.222381),
    (-0.525532, 0.313707), (-0.183435, 0.362684),
    (0.183435, 0.362684), (0.525532, 0.313707),
    (0.796667, 0.222381), (0.96029, 0.101229)
]

sum = 0.0
for x, w in weights:
    sum += w * f(x)

print(f'Quadrature result: {sum}\tError: {abs(pi/2 - sum)}')
\end{lstlisting}

\noindent
\textbf{Wnioski:} Ta metoda pozwala uzyskać bardzo dokładne wyniki niskim kosztem obliczeniowym w bardzo prosty sposób. Dla wyższych rzędów trudnością może być znalezienie węzłów i wag, więc w praktyce często warto zastosować złożenie obliczeń dla niższych rzędów.

\newpage

\section{Rozwiązania zadań domowych}

\subsection{}
Do obliczeń zastosowałem poniższy program w języku C. W całkowaniu adaptacyjnym zastosowałem wzór prostokątów.

\begin{lstlisting}[language=C]
#include <stdio.h>
#include <math.h>

#define RECURS_LEVEL_MAX  100

// pointer to function of one variable
typedef double (* FuncFp)(double);

double fun(double x) {
    return 1. / (x*x + 1);
}

// pointer to quadrature function
typedef double (* QuadratureFp)(FuncFp, double, double, int);

// rectangle rule, midpoint
double quad_rect_mid(FuncFp f, double a, double b, int n) {
    double h = (b - a) / n;
    double sum = 0;
    for (double x = a + (h / 2); x < b; x += h)
        sum += f(x);
    return h * sum;
}

// adaptive algorithm
double adaptive(FuncFp f, double a, double b, double S,
        double tolerance, QuadratureFp quad, int level) {
    double S1 = quad(f, a, (a + b) / 2, 1);
    double S2 = quad(f, (a + b) / 2, b, 1);
    if (fabs(S1 + S2 - S) <= tolerance)
        return S1 + S2;
    if (level == RECURS_LEVEL_MAX) // for safety
        return NAN;
    double result1 = adaptive(f, a, (a + b) / 2, S1,
                        tolerance / 2, quad, level + 1);
    double result2 = adaptive(f, (a + b) / 2, b, S2,
                        tolerance / 2, quad, level + 1);
    return result1 + result2;
}

// initialization for adaptive algorithm
double init_adaptive(FuncFp f, double a, double b,
                double tolerance, QuadratureFp quad) {
    double S = quad(f, a, b, 1);
    return adaptive(f, a, b, S, tolerance, quad, 1);
}
\end{lstlisting}

\newpage

\begin{lstlisting}[language=C, firstnumber=48]
int main() {
    const double correct = log(2);

    double S = quad_rect_mid(fun, 0, 1, 10);
    printf("Rectangle rule (h = 0.1):\n");
    printf("S = %.10f, Error = %.10f\n\n", S, fabs(correct - S));

    S = init_adaptive(fun, 0, 1, 0.1, quad_rect_mid);
    printf("Adaptive algorithm (tolerance = 0.1):\n");
    printf("S = %.10f, Error = %.10f\n\n", S, fabs(correct - S));

    S = init_adaptive(fun, 0, 1, 0.005, quad_rect_mid);
    printf("Adaptive algorithm (tolerance = 0.005):\n");
    printf("S = %.10f, Error = %.10f\n", S, fabs(correct - S));

    return 0;
}
\end{lstlisting}

\noindent
Program wypisuje poniższe rezultaty:

\begin{verbatim}
Rectangle rule (h = 0.1):
S = 0.7856064963, Error = 0.0924593157

Adaptive algorithm (tolerance = 0.1):
S = 0.7905882353, Error = 0.0974410547

Adaptive algorithm (tolerance = 0.005):
S = 0.7854335733, Error = 0.0922863927
\end{verbatim}

\noindent
\textbf{Wnioski:} Dla mało skomplikowanych funkcji jak ta, mało skomplikowane metody jak wzór prostokątów przy odpowiedniej ilości podziałów mogą być wystarczające do uzyskania wyników podobnie zadawalających jak metody adaptacyjnej (która dokładniejszy wynik daje dopiero przy wyraźnie niskiej tolerancji na błędy). 

\subsection{}

\section{Bibliografia}
Materiały ze strony - Włodzimierz Funika\\
https://www.efunda.com/math/num\_integration/findgausslegendre.cfm

\end{document}
